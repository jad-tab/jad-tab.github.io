---
title: "Saving animals with Machine Learning"
date: 2020-11-17
tags: [data preprocessing, data cleaning, classification, gradient boosting, random forest, kaggle]
header:
 image: 
excerpt: "In this article, I build predictive models to predict what's going to happen to animals abandonned in shelters."
mathjax: "true"
---


About 100 000 cats and dogs are abandonned by their owners every year in France. Some of them are left to a cruel fate, and on some rare occasions have to be taken away from their owners for abuse.
The SPA (Société de Protection des Animaux) fosters about 40 000 of these animals. It also seems that summer is particularly bad season for the pets.

Here are a few cute animals you can adopt from [Animals Lebanon:](http://www.animalslebanon.org/)


![alt]({{ site.url }}{{ site.baseurl }}/figures/animals.PNG)

But what happens to them after that ? 
Unfortunately, with the ever-increasing number of abandonned animals, some can stay fostered long enough to die in the shelter. Others may even have to be euthanized. And a lucky few are offered a new home after being adopted.

Is it possible to predict what happens to these fostered animals down the road using their characteristics ? (such as their age, breed, color...).

Using a dataset from the [Shelter Animal Outcomes (Kaggle Competition)](https://www.kaggle.com/c/shelter-animal-outcomes/overview), I'm going to build predictive models to predict the animals' destinies. Though the dataset comes from a Kaggle competition, I'm not focusing here on building the most accurate model possible. Instead, I will take my time preprocessing the data and cleaning it: as we're going to see, the real world data isn't always very tidy and requires some extra steps. 


And also, just a foreword: I'll use the multiclass logarithmic function which is a way to measure how good the predictions are. After training the algorithm, I will determine for each animal $$i$$ all the probabilities for it to be in the class $$j$$, $$j$$ being one of those categories ('Adoption', 'Died', 'Euthanasia', 'Return to owner', and 'Transfer'). Then I will compute the following quantity:

$$LogLoss = \frac{-1}{N} \sum_{i = 1}^{N} \sum_{j = 1}^M y_{ij} log(p_{ij})$$

Where:

* $$M = 5$$ (number of outcome classes), 
* $$y_{ij} = 1$$ (if observation $$i$$ is in outcome $$j$$), $$y_{ij} = 0$$ (if observation $$i$$ is not in outcome $$j$$).


Let's get coding. I start by importing the relevant functions and to import and visualize the data:

```python
import itertools
import numpy as np
import pandas as pd
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.metrics import log_loss
from sklearn.model_selection import GridSearchCV


complete_data = pd.read_csv('train.csv.gz')
complete_data.head()
```

![alt]({{ site.url }}{{ site.baseurl }}/figures/algo1.PNG)


## Dropping some features, converting some others
I'm going to drop the animal's names to begin with, as well as the animal ID's.
The 'OutcomeSubtype' is not necessary because it does not provide any additional information: it's only known after the 'Outcometype' has been determined (it is only a qualitative precision after the animal departs and including it might create a bias in the characteristics). 

I'll also make the SexUponOutcome 'atomic' (since it contains two information at the same time: whether the animal has been castrated and whether itis male or female). I'll split it into two columns. 

AgeUponOutcome represents the age in time units (years, months, weeks, days) but for the sake of simplicity, I'll adopt a year-base convention. Let's just say that $$1 \text{ year} \approx 365 \text{ days} \approx 52 \text{ weeks}$$.

All the variables (except for the age) are categories I'll later convert them to categorical variables.



```python
#Remove AnimalID, Name and Outcome Subtype
#Transform the 'Castrated' column into 0 for all Intact animals and 1 for all the Neutered and Spayed animals. 

complete_data = complete_data[complete_data.columns.difference(('AnimalID', 'Name', 'OutcomeSubtype'))].copy()

complete_data.loc[complete_data['Castrated']=='Intact', 'Castrated'] = 0
complete_data.loc[complete_data['Castrated'].isin(('Neutered', 'Spayed')), 'Castrated'] = 1

```
This is what the data looks like by now:

![alt]({{ site.url }}{{ site.baseurl }}/figures/algo2.PNG)



## Dealing with missing values

Now I'll deal with missing values, whether the label is 'unknown' or the cell is null. How many are there?
I noticed that less than 4% of the data had missing attributes in 'Castrated', so I just proceeded to delete all those entries. Same for the 'Sex' column.
After that is done, we no longer need the 'Sex upon outcome' column, since all its attributes were extracted. 

```python
(complete_data['Castrated'] == 'Unknown').sum() / complete_data.shape[0]
complete_data['Castrated'].isnull().sum() / complete_data.shape[0]
complete_data = complete_data.loc[complete_data['Castrated'].isin((0, 1))]

complete_data.loc[complete_data['Sex']=='Female', 'Sex'] = 0
complete_data.loc[complete_data['Sex']=='Male', 'Sex'] = 1
complete_data = complete_data.loc[complete_data['Sex'].isin((0, 1))]

complete_data = complete_data.loc[:, complete_data.columns != 'SexuponOutcome']

```

![alt]({{ site.url }}{{ site.baseurl }}/figures/algo3.PNG)

### Dealing with the Seasons

As I mentionned earlier, it seems that the period of the year changes something in the adoption rates. So an educated guess would be to take this into consideration while dealing with the "DateTime".
I'll map each of the pandas timestamps to itself minus the first day of the year and convert this time difference into a float using the 365-day convention: this is how we construct 'FractionofYear'. In other words, I'll convert the information in the "DateTime" to "fraction of the year" to retain the information about the period of the year we're in.

'FractionofDay' is exactly the same thing but for days (and a 24 hour/day convention). Then, these two columns are discarded.

```python
complete_data['DateTime'] = pd.to_datetime(complete_data['DateTime'], format='%Y-%m-%d %H:%M:%S')
complete_data['FractionOfYearFromBeginningOfYear'] = complete_data['DateTime'].map(
    lambda x: (x-pd.Timestamp(year=x.year, month=1, day=1)).days/365
)
complete_data['FractionOfDay'] = complete_data['DateTime'].map(lambda x: x.hour/24)

complete_data = complete_data.loc[:, complete_data.columns != 'DateTime']

```


![alt]({{ site.url }}{{ site.baseurl }}/figures/algo4.PNG)
